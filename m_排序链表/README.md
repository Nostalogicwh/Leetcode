# 题目
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

# 解题思路
分为两个环节，分割、合并
- 分割：找到当前链表中点，并从中点将链表断开（在下次递归cut时，链表片段拥有正确边界）
	- 使用快慢指针找到中点，奇数个节点为中点，偶数个节点为中心左边的节点
	- 找到中点slow，令slow.next = None切断链表
	- 递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。
	- cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。
- 合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。
	- 双指针法合并，建立辅助ListNode h 作为头部。
	- 设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。
	- 返回辅助ListNode h 作为头部的下个节点 h.next。
	- 时间复杂度 O(l + r)，l, r 分别代表两个链表长度。
- 当题目输入的 head == None 时，直接返回None。