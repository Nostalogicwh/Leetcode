# 题目
给定一个数字字符串 S，比如 S = "123456579"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。  

形式上，斐波那契式序列是一个非负整数列表 F，且满足：

- 0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；
- F.length >= 3；
- 对于所有的0 <= i < F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。
另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。  

返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。

# 解题思路
确定前两个元素的位数，来匹配后面的元素是否符合斐波那契数列的规律。  
定义子函数match(m,n,S)，m,n分别为斐波那契数列的前两位元素的位数，根据前两个元素确定后面的元素是否在接下来的字符串中，若存在，则继续遍历，反复循环，直到遍历全部，若不存在，则返回false。  
遍历完后，检查斐波那契数组的元素总位数是否等于字符串长度，若相等，则返回True和斐波那契数列，若不等，说明中间存在0元素，使得斐波那契数列元素总位数小于字符串长度。  
由于m,n长度不可能超过数组长度的一半，设置两个for循环,依次带入match(i,j,S)函数，看是否返回true，若返回true，由于位数限制，我们只需要比较斐波那契数列最后一个元素是否大于2/*/*31-1，若大于，返回空集，否则返回斐波那契数列。